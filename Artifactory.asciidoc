=== Content Management: JFrog Artifact

The Content Management (based on a software library) will hold any versioned
software artifacts (source or binary) that are relevant for production use.
The Content Governor will use different services provided to accompish the tasks
of the content management domain. For the purpose of this Reference
Implementation JFrog Artifactory PRO (short: Artifactory) will be used.

Artifactory will not only be the central point of content ingestion, but will
also be used as a repository for intermediate binary artifacts.

==== Artifactory Components

===== Artifactory PRO

The main component is Artifactory PRO. It may be deployed on {{OCP}} or on a
separate host as a standalone application. A base configuration of the
application is done via a ConfigMap ({{OCP}} case) or classic configuration
files (standalone case). Data is persistent to volumes and a (persistent)
PostgreSQL database. Customization, such as creation of repositories required
for ACME Corp IT-Dev operation, is done via an Ansible playbook.

===== Storage and Database

Storage for artifacts and the PostgreSQL database is provided via a NFS-backed
PersistentVolumes ({{OCP}}) or the local filesystem of the host running
Artifactory. The PostgreSQL database is used exclusively for Artifactory
({{OCP}}). PersistentVolumes are provisioned from one (SPOF, but out of scope)
NFS server and are not backed up (FAIL, but {{oos}}).

===== Reverse Proxy

To implement Artifactory’s requirements for how to provide a docker registry a
NGINX based reverse proxy is implemented. This will rewrite URL and pass them
on to the Artifactory PRO component.

All components can be deployed and undeployed from a single {{OCP}} template
via an Ansible playbook.

The following diagram will give an overview of the content management
architecture.

.Content Management Architecture Overview
image::images/cont-mgmt-architecture.png[Content Management Architecture Overview]

==== Interactions - User Stories

===== Administration by Content Governor (1)
The first interaction pattern implemented is related to content management,
including creation of local and remote repositories etc. A role call Content
Governor would either execute manual task via the Artifactory web user interface
or automated tasks via the REST API. Both interfaces offer the same functions.

===== Pulling Content for Builds (2)
The second interaction pattern is related to OCP Builds and ImageStreams. They
interface with Artifactory via HTTP/HTTPS to access Docker, Maven, NPM or Bower
repositories. In the case of Docker repository access a reverse proxy (3) is
used to translate docker registry interactions to Artifactory repository
interactions. This is required as Artifactory can host any number of Docker
registries, see the Artifactory documentation for details on Registries and
Repositories. All other repositories are accessed directly (4) without the need
of a reverse proxy.

Artifactory configuration and repository data is stored in a PostgreSQL database
and on a persistent storage volume, provided by a NFS server (5).

===== Proxying Content from remote Repositories (6)
All so called remote repositories implement a caching proxy for remote/upstream
repositories. Content within these repositories is cached for a certain amount
of time on storage. This is especially useful to speed up OCP Builds, as
required content must not be downloaded from the internet but from Artifactory’s
caching repository.

==== Implementation of Content Management

Two scenarios for implementation of the Content Management Services are feasible:

 * Artifactory and the reverse proxy via RPMs on a separate host
 * Artifactory and the reverse proxy as containerized components on OCP

Due to some limitations of Artifactory on OCP, we have chosen to implement
scenario 1.

Therefor we will deploy a RHEL7.3 host, including a OpenJDK Java runtime
environment and NGINX as a web-server.

.Artifactory Component Overview
image::images/cont-mgmt-components.png[Artifactory Component Overview]

Deploying and registering the host is out of scope for this Reference
Implementation, the following repositories must be enabled:

[format="csv",cols="2"]
[options="header"]
[frame="topbot",grid="none"]
|======
Repository ID, Repository Name
rhel-7-server-rpms, Red Hat Enterprise Linux 7 Server (RPMs)
rhel-server-rhscl-7-rpms, Red Hat Software Collections RPMs for Red Hat Enterprise Linux 7 Server
|======

==== Building the Artifactory container image

Please change to `container-image/artifactory` and have a look at the `Makefile`, change
`REPOSITORY_NAME` according to your needs.

A simple `make push` should do the rest.

```
cd container-image/artifactory
make push
```

Mind the Gap! There is a build id in the `Makefile` and the `artifactory.yaml` and in the `Dockerfile`

`make push` will build and push the Pro and OSS version of Artifactory.

==== Creating Artifactory template

An OpenShift template is provided and could be used to instanciate new Artifactory
applications. Therefore the template needs to be created on OpenShift: `oc create -f artifactory.yaml`.
This assumes that you have create a project on OpenShift, for detailed instruction
see Creating a Project[https://docs.openshift.org/latest/dev_guide/projects.html#create-a-project].

==== Creating Artifactory application

Deploying Artifactory on OpenShift is a simple step of instanciating a new
application on OpenShift. To provide default configurations to Artifactory,
a ConfigMap will be used, this is not created by the template. Please create
it beforehand.

If you want to use the Pro version of Artifactory, please provide a license key
via the config map, and overwrite the *ARTIFACTORY_IMAGE_NAME* of the template.

===== Artifactory default Config Map

To configure Artifactory a config map is created from the contents of `etc-opt-jfrog-artifactory-dist/`.
The following files must be present:
```
-rw-rw-r--. 1 user group  9858 Oct 22 19:58 artifactory.config.xml
-rw-rw-r--. 1 user group   856 Oct 24 16:14 artifactory.lic
-rw-rw-r--. 1 user group 11045 Oct 22 19:58 artifactory.system.properties
-rw-rw-r--. 1 user group   476 Oct 22 19:58 default
-rw-rw-r--. 1 user group  6858 Oct 22 19:58 logback.xml
-rw-rw-r--. 1 user group  5546 Oct 22 19:58 mimetypes.xml
```

Especially `artifactory.lic` is required if you run the Pro version.

The following commands will create the config map and instanciate the new Artifactory
application.

```
oc create configmap artifactory-default-config --from-file=etc-opt-jfrog-artifactory-dist/
oc new-app --template=acme-dev-infra/artifactory --param=ARTIFACTORY_IMAGE_NAME=artifactory-pro # or artifactory-oss
```

==== Initializing Artifactory

To get a quick start an Ansible playbook is provided to create a few repositories.
At least you need to customize the hostname of Artifactory, to see which hostname
is currently used, try `oc get route artifactory -o template --template={{.spec.host}}`.
This hostname should be set as variable `artifactory_host` in the playbook.

To execute the playbook run `cd playbooks && ansible-playbook create-default-repositories.yaml`. If the
repositories exists, failures will be shown, but ignored by the ansible execution.
Please make sure that any Docker type repositories have Token Authentication
enabled.

These steps are implemented and provided for your convenience as an <<playbooks/deploy-service.yaml#Ansible playbook,Ansible playbook>>.

==== Remove application from OCP

```
oc scale deploymentconfig artifactory-postgresql --replicas=0
oc delete service artifactory
oc delete service artifactory-postgresql
oc delete petset artifactory
oc delete deploymentconfig artifactory-postgresql
oc delete routes artifactory
oc delete pod --all
oc delete imagestream artifactory
oc delete configmap artifactory-default-config
oc delete template artifactory
```

Persistent Volumes are not deleted using these commands.
